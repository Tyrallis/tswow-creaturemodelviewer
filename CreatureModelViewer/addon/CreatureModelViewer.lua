--[[
    Creature Model Viewer (CMV)
    TSWoW addon — view creature models by entry, path, or target.

    Data flow: entry → CreatureDisplayIdMap → displayId → CreatureModelPathMap → .m2 path
    Load: SetCreature(displayId) and/or SetModel(path). Use "Prefer textures" to choose order.

    Commands: /cmv [entry] | /cmv path <path> | /cmv unit
    See README in this repository for installation and usage.
]]

local VIEWER_FRAME  = "MagicCoreCreatureModelViewerFrame"
local DEBUG_FRAME   = "MagicCoreCreatureModelViewerDebugFrame"
local DEFAULT_SCALE = 0.25   -- starting scale; scroll to adjust

-- When true: try SetCreature(displayId) first so Texture1/2/3 (BLP) apply; fall back to SetModel(path) if model doesn't draw.
if _G.MagicCoreCMVPreferTextures == nil then _G.MagicCoreCMVPreferTextures = false end

local RefreshDebugPanel  -- forward ref so OpenViewer closure can call it

local ATLAS_VIS_ON  = "128-RedButton-VisibilityOn"
local ATLAS_VIS_ON_H = "128-RedButton-VisibilityOn-Highlight"
local ATLAS_VIS_ON_P = "128-RedButton-VisibilityOn-Pressed"
local ATLAS_VIS_OFF = "128-RedButton-VisibilityOff"
local ATLAS_VIS_OFF_H = "128-RedButton-VisibilityOff-Highlight"
local ATLAS_VIS_OFF_P = "128-RedButton-VisibilityOff-Pressed"

local ATLAS_SPAWN     = "128-RedButton-Cart-Add"
local ATLAS_SPAWN_H   = "128-RedButton-Cart-Add-Highlight"
local ATLAS_SPAWN_P   = "128-RedButton-Cart-Add-Pressed"
local ATLAS_DELETE    = "128-RedButton-Delete"
local ATLAS_DELETE_H  = "128-RedButton-Delete-Highlight"
local ATLAS_DELETE_P  = "128-RedButton-Delete-Pressed"
local ATLAS_CHECKBOX  = "checkbox-minimal"
local ATLAS_CHECKMARK = "checkmark-minimal"

-- Arrow buttons only: point at your BLP. File: Interface\Shop\CatalogShop128RedButton.BLP (Spawn/Delete use default atlases)
if C_Texture and C_Texture.LoadAtlasData then
    local atlasData = {
        ["Interface/Shop/CatalogShop128RedButton"] = {
            ["128-RedButton-ArrowDown"]            = {128, 128, 0.576172, 0.826172, 0.254395, 0.316895, false, false, "1x"},
            ["128-RedButton-ArrowDown-Highlight"]  = {128, 128, 0.576172, 0.826172, 0.381348, 0.443848, false, false, "1x"},
            ["128-RedButton-ArrowDown-Pressed"]    = {128, 128, 0.00195312, 0.251953, 0.444824, 0.507324, false, false, "1x"},
        },
        ["Interface/Common/MinimalCheckbox"] = {
            ["checkbox-minimal"] = {30, 29, 0.015625, 0.484375, 0.015625, 0.46875, false, false, "1x"},
            ["checkmark-minimal-disabled"] = {30, 29, 0.515625, 0.984375, 0.015625, 0.46875, false, false, "1x"},
            ["checkmark-minimal"] = {30, 29, 0.015625, 0.484375, 0.5, 0.953125, false, false, "1x"},
        },
    }
    C_Texture.LoadAtlasData(atlasData)
end

local function Log(msg)
    if DEFAULT_CHAT_FRAME then
        DEFAULT_CHAT_FRAME:AddMessage("|cff00bfff[CMV]|r " .. tostring(msg))
    end
end

-- WotLK: SetColorTexture does not exist; use a solid texture + SetVertexColor
local function SetSolidColor(tex, r, g, b, a)
    if not tex then return end
    if tex.SetColorTexture then
        tex:SetColorTexture(r, g, b, a or 1)
        return
    end
    tex:SetTexture("Interface\\Buttons\\WHITE8x8")
    tex:SetVertexColor(r or 1, g or 1, b or 1)
    tex:SetAlpha(a or 1)
end

-- ── Path resolution ───────────────────────────────────────────────────────────

-- Normalize key to number so lookup works whether entry/displayId came as string or number.
-- Generated maps use number keys [69975] = ...; some code paths may pass string "69975".
local function GetDisplayIdFromEntry(entry)
    if type(CreatureDisplayIdMap) ~= "table" or not entry then return nil end
    local n = tonumber(entry)
    if not n or n <= 0 then return nil end
    return CreatureDisplayIdMap[n] or CreatureDisplayIdMap[tostring(n)]
end

local function GetPathFromDisplayId(displayId)
    if type(CreatureModelPathMap) ~= "table" or not displayId then return nil end
    local n = tonumber(displayId)
    if not n or n <= 0 then return nil end
    return CreatureModelPathMap[n] or CreatureModelPathMap[tostring(n)]
end

local function ResolvePathFromEntry(entry)
    local displayId = GetDisplayIdFromEntry(entry)
    if not displayId then return nil, nil end
    return GetPathFromDisplayId(displayId), displayId
end

-- Returns ordered list of all displayIds (texture variants) for an entry.
-- CreatureVariantsMap[entry] = {displayId1, displayId2, ...} generated by datascripts.
-- Falls back to {modelid1} if the map is absent.
local function GetVariantsForEntry(entry)
    local n = tonumber(entry)
    if not n or n <= 0 then return {} end
    if type(CreatureVariantsMap) == "table" then
        local v = CreatureVariantsMap[n] or CreatureVariantsMap[tostring(n)]
        if v then return v end
    end
    local did = GetDisplayIdFromEntry(n)
    if did then return {did} end
    return {}
end

-- ── Camera ────────────────────────────────────────────────────────────────────
--
-- Called ONCE after the model loads, never again.
-- SetCamera(0) disables the M2's embedded camera animation so our
-- SetPosition and SetModelScale actually stick.
-- After this call we only ever touch SetModelScale (scale), SetFacing (rotation) — never SetCamera again.

-- Force static pose so animation doesn't override rotation (helps newer/custom M2s).
local function FreezeModelPose(model)
    if not model then return end
    pcall(model.SetSequence, model, 0)
    pcall(model.SetSequenceTime, model, 0, 0)
end

-- Default Z offset so creatures with ground effects or large bases aren't cut off at the bottom
local MODEL_VERTICAL_OFFSET = 0.35

-- cameraOverride: if not nil, use instead of 0 so user's SetCamera value persists when changing models
local function InitCamera(model, scale, cameraOverride)
    local cam = (cameraOverride ~= nil) and cameraOverride or 0
    pcall(model.SetCamera, model, cam)
    model:SetPosition(0, 0, MODEL_VERTICAL_OFFSET)
    model:SetFacing(0)
    model:SetModelScale(scale or DEFAULT_SCALE)
    FreezeModelPose(model)
    -- Same as Character Info / Dressing Room: use SetRotation(radians), store on model
    model.rotation = 0.61
    pcall(model.SetRotation, model, 0.61)
    local parent = model:GetParent()
    if parent then
        parent.CMVFacing = 0
        -- If user had an animation selected, play it on the new model instead of leaving it frozen
        local seq = parent.CMVSequence
        if type(seq) == "number" then
            model._lastSequenceApply = GetTime()
            pcall(model.SetSequence, model, seq)
            pcall(model.SetSequenceTime, model, seq, 0)
        end
    end
end

-- ── Model loading ─────────────────────────────────────────────────────────────

local function LoadByPath(model, path)
    if type(path) ~= "string" or path == "" then return false end
    local function try(p)
        local norm = p:gsub("/", "\\")
        local ok, err = pcall(model.SetModel, model, norm)
        if ok then Log("SetModel OK: " .. norm); return true end
        Log("SetModel failed: " .. tostring(err)); return false
    end
    -- In-game client usually needs .m2; DBC/generated paths often say .mdx. Try .m2 first when path is .mdx.
    if path:lower():match("%.mdx$") then
        local m2path = path:gsub("%.mdx$", ".m2"):gsub("%.MDX$", ".m2")
        if try(m2path) then return true end
    end
    if try(path) then return true end
    return false
end

local function LoadByDisplayId(model, displayId)
    if not displayId or displayId <= 0 then return false end
    if not model.SetCreature then return false end
    local ok, err = pcall(model.SetCreature, model, displayId)
    if ok then Log("SetCreature OK: " .. tostring(displayId)); return true end
    Log("SetCreature failed: " .. tostring(err)); return false
end

-- SetCreature takes a creature_template ENTRY, not a CreatureDisplayInfo ID.
-- The client resolves: entry → Creature.dbc → displayId → CreatureDisplayInfo
--   → ModelID → CreatureModelData → path+textures.
-- Passing a displayId (e.g. 33011) as the argument looks up entry 33011, which
-- is either a vanilla creature or nothing — wrong model or blank.
local function LoadByEntry(model, entry)
    if not entry or entry <= 0 then return false end
    if not model.SetCreature then return false end
    local ok, err = pcall(model.SetCreature, model, entry)
    if not ok then Log("SetCreature(entry=" .. tostring(entry) .. ") error: " .. tostring(err)); return false end
    -- SetCreature never throws on unknown entries — validate with GetModel()
    local loaded = model:GetModel()
    if not loaded or loaded == "" then
        Log("SetCreature(entry=" .. tostring(entry) .. ") silent fail — not in client Creature.dbc")
        return false
    end
    Log("SetCreature(entry=" .. tostring(entry) .. ") OK → " .. tostring(loaded))
    return true
end

local function NormalizePathForLookup(path)
    if type(path) ~= "string" or path == "" then return nil end
    local p = path:gsub("\\", "/"):gsub("^/+", "")
    -- Prefer .m2 so we never store .mdx (viewer displays/fallback use .m2)
    p = p:gsub("%.[mM][dD][xX]$", ".m2")
    return p
end

-- SetUnit needs one blank render frame between ClearModel and the call.
local function LoadByUnitAsync(model, unit, onDone)
    if not UnitExists(unit) then Log("No target"); return false end
    model:ClearModel()
    model:SetScript("OnUpdate", function(self)
        self:SetScript("OnUpdate", nil)
        local ok, err = pcall(self.SetUnit, self, unit)
        if ok then
            Log("SetUnit OK: " .. (UnitName(unit) or "?"))
            -- SetUnit positions the model automatically; don't override with InitCamera
            if onDone then onDone(self) end
        else
            Log("SetUnit failed: " .. tostring(err))
        end
    end)
    return true
end

-- ── Viewer ────────────────────────────────────────────────────────────────────

local function SetViewerTitle(title)
    local f = _G[VIEWER_FRAME]
    if not f then return end
    if f.Title and f.Title.Text then f.Title.Text:SetText(title or "Creature Viewer") end
    if f.InfoText then f.InfoText:SetText(title or "") end
end

local function ShowDebugText(msg)
    local f = _G[VIEWER_FRAME]
    if f and f.DebugText then f.DebugText:SetText(msg); f.DebugText:Show() end
end

--
-- Load sequence:
--   tick 1 — second ClearModel (belt-and-suspenders)
--   tick 2 — call loadFn(model)
--   tick 3+4 — wait for renderer to process the new model
--   tick 5 — call InitCamera so it sticks after the model is fully resident
--
local PORTRAIT_ICON       = "Interface\\Icons\\UI_Profession_Engineering"
local DEBUG_PORTRAIT_ICON = "Interface\\Icons\\_Interact_Shaman"

-- ── Texture variant switcher ─────────────────────────────────────────────────
--
-- Each texture variant = one CreatureDisplayInfo.dbc row with different TextureVariation_1/2/3.
-- SetCreature(displayId) loads a specific variant; the mesh is the same, only textures differ.

local function LoadVariant(displayId)
    local f = _G[VIEWER_FRAME]
    if not f or not f.Model then return end
    f.CurrentDisplayId = displayId
    local model = f.Model
    -- Kill any in-progress update, clear, wait one frame, then SetCreature
    f:SetScript("OnUpdate", nil)
    model:SetScript("OnUpdate", nil)
    model:ClearModel()
    local df = _G[DEBUG_FRAME]
    local camOverride = (df and df.CameraValue ~= nil) and df.CameraValue or nil
    local tick = 0
    f:SetScript("OnUpdate", function()
        tick = tick + 1
        if tick == 1 then
            model:ClearModel()
        elseif tick == 2 then
            local ok = LoadByDisplayId(model, displayId)
            if not ok then
                -- Fallback: path-only (no textures)
                local p = GetPathFromDisplayId(displayId)
                if p then LoadByPath(model, p) end
            end
        elseif tick >= 5 then
            f:SetScript("OnUpdate", nil)
            InitCamera(model, f.CMVScale or DEFAULT_SCALE, camOverride)
            model:Show()
            model:SetScript("OnUpdate", OnModelUpdate)
            if df and df:IsVisible() and type(RefreshDebugPanel) == "function" then
                RefreshDebugPanel()
            end
        end
    end)
end

local function UpdateVariantUI(f)
    if not f then return end
    local variants = f.CMVVariants or {}
    local idx      = f.CMVVariantIdx or 1
    local count    = #variants
    -- Show/hide the whole row
    if f.VariantRow then
        if count > 1 then f.VariantRow:Show() else f.VariantRow:Hide() end
    end
    if f.VariantLabel then
        f.VariantLabel:SetText(count > 1 and ("Skin " .. idx .. " / " .. count) or "")
    end
    if f.VariantPrevBtn then
        if idx > 1 then f.VariantPrevBtn:Enable() else f.VariantPrevBtn:Disable() end
    end
    if f.VariantNextBtn then
        if idx < count then f.VariantNextBtn:Enable() else f.VariantNextBtn:Disable() end
    end
end

local function EnsureVariantUI(f)
    if f.VariantRow then return end
    -- Row sits just below the model, above the spawn/delete buttons
    local row = CreateFrame("Frame", nil, f)
    row:SetSize(240, 26)
    -- Anchor above bottom of MetalBorder (same level as InfoText area)
    row:SetPoint("BOTTOM", f, "BOTTOM", 0, 44)
    row:Hide()
    f.VariantRow = row

    local prevBtn = CreateFrame("Button", nil, f, "UIPanelButtonTemplate")
    prevBtn:SetSize(28, 22)
    prevBtn:SetPoint("LEFT", row, "LEFT", 4, 0)
    prevBtn:SetText("<")
    prevBtn:SetScript("OnClick", function()
        local idx = f.CMVVariantIdx or 1
        if idx <= 1 then return end
        f.CMVVariantIdx = idx - 1
        local did = (f.CMVVariants or {})[f.CMVVariantIdx]
        if did then LoadVariant(did) end
        UpdateVariantUI(f)
    end)
    f.VariantPrevBtn = prevBtn

    local label = f:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
    label:SetPoint("CENTER", row, "CENTER", 0, 0)
    label:SetText("")
    f.VariantLabel = label

    local nextBtn = CreateFrame("Button", nil, f, "UIPanelButtonTemplate")
    nextBtn:SetSize(28, 22)
    nextBtn:SetPoint("RIGHT", row, "RIGHT", -4, 0)
    nextBtn:SetText(">")
    nextBtn:SetScript("OnClick", function()
        local idx   = f.CMVVariantIdx or 1
        local count = #(f.CMVVariants or {})
        if idx >= count then return end
        f.CMVVariantIdx = idx + 1
        local did = (f.CMVVariants or {})[f.CMVVariantIdx]
        if did then LoadVariant(did) end
        UpdateVariantUI(f)
    end)
    f.VariantNextBtn = nextBtn
end

-- Build a loader function for a given creature entry (used by slash and by reload-from-checkbox).
-- Prefer textures ON: try SetCreature(entry) first so vanilla IDs get correct BLP; fall back to SetModel(path) if model doesn't draw.
-- Prefer textures OFF: try SetModel(path) first so unchecking visibly reloads (path-only); fall back to SetCreature if path fails.
local function MakeEntryLoader(entry, displayId)
    local f = _G[VIEWER_FRAME]
    return function(model)
        local resolvedPath, resolvedDisplayId = ResolvePathFromEntry(entry)
        if resolvedPath then
            if f then f.CurrentModelPath = NormalizePathForLookup(resolvedPath) end
            if _G.MagicCoreCMVPreferTextures then
                -- Prefer textures: SetCreature first (BLP from client DBC), then path fallback
                if LoadByEntry(model, entry) then
                    if f then f.CurrentDisplayId = resolvedDisplayId; f.CMVFallbackPath = NormalizePathForLookup(resolvedPath) end
                    return true
                end
                if LoadByPath(model, resolvedPath) then
                    if f then f.CurrentDisplayId = nil; f.CMVFallbackPath = nil end
                    return true
                end
                if LoadByEntry(model, entry) then
                    if f then f.CurrentDisplayId = resolvedDisplayId; f.CMVFallbackPath = NormalizePathForLookup(resolvedPath) end
                    return true
                end
            else
                -- Prefer path: SetModel first so unchecking the box visibly reloads with path
                if LoadByPath(model, resolvedPath) then
                    if f then f.CurrentDisplayId = nil; f.CMVFallbackPath = nil end
                    return true
                end
                if LoadByEntry(model, entry) then
                    if f then f.CurrentDisplayId = resolvedDisplayId; f.CMVFallbackPath = NormalizePathForLookup(resolvedPath) end
                    return true
                end
            end
            return false
        end
        if displayId and displayId > 0 then
            local p = GetPathFromDisplayId(displayId)
            if p then
                if f then f.CurrentModelPath = NormalizePathForLookup(p) end
                if LoadByDisplayId(model, displayId) then
                    if f then f.CurrentDisplayId = displayId end
                    return true
                end
                if f then f.CurrentDisplayId = nil end
                return LoadByPath(model, p)
            end
        end
        local pByDisplayId = GetPathFromDisplayId(entry)
        if pByDisplayId then
            if f then f.CurrentModelPath = NormalizePathForLookup(pByDisplayId) end
            if LoadByDisplayId(model, entry) then
                if f then f.CurrentDisplayId = entry end
                return true
            end
            if LoadByPath(model, pByDisplayId) then
                if f then f.CurrentDisplayId = nil end
                return true
            end
        end
        if f then f.CurrentModelPath = nil; f.CurrentDisplayId = nil end
        ShowDebugText("No path for entry " .. entry .. "\nRun: tswow datascripts build")
        return false
    end
end

local function MakePathLoader(path)
    local f = _G[VIEWER_FRAME]
    return function(model)
        if f then f.CurrentModelPath = NormalizePathForLookup(path); f.CurrentDisplayId = nil end
        return LoadByPath(model, path)
    end
end

-- Setup "Prefer textures" checkbox: 36x36, atlas checkbox-minimal / checkmark-minimal, toggle + reload.
-- Uses ARTWORK-layer textures (check.Box, check.Check) so they draw; built-in NormalTexture/CheckedTexture can be invisible.
local function SetupPreferTexturesCheck(parentFrame)
    local check = parentFrame and parentFrame.PreferTexturesCheck
    if not check then return end
    local boxTex = check.Box
    local checkTex = check.Check
    if boxTex then
        boxTex:SetAllPoints(check)
        if boxTex.SetAtlas then
            boxTex:SetAtlas(ATLAS_CHECKBOX)
        else
            boxTex:SetTexture("Interface\\Buttons\\UI-CheckBox-Up")
        end
        boxTex:Show()
    end
    if checkTex then
        checkTex:SetAllPoints(check)
        if checkTex.SetAtlas then
            checkTex:SetAtlas(ATLAS_CHECKMARK)
        else
            checkTex:SetTexture("Interface\\Buttons\\UI-CheckBox-Check")
        end
        checkTex:SetBlendMode("BLEND")
        if _G.MagicCoreCMVPreferTextures then checkTex:Show() else checkTex:Hide() end
    end
    check:SetFrameLevel(check:GetParent():GetFrameLevel() + 5)
    check:SetChecked(_G.MagicCoreCMVPreferTextures and true or false)
    check:SetScript("OnClick", function(self)
        _G.MagicCoreCMVPreferTextures = self:GetChecked()
        if checkTex then if self:GetChecked() then checkTex:Show() else checkTex:Hide() end end
        if _G.MagicCoreCMV_ReloadCurrentModel then _G.MagicCoreCMV_ReloadCurrentModel() end
    end)
    check:SetScript("OnEnter", function(self)
        if GameTooltip then
            GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
            GameTooltip:SetText("Prefer textures (SetCreature)\nWhen ON: try SetCreature first for correct BLP; fall back to path if model does not draw.\nWhen OFF: try SetModel(path) first; fall back to SetCreature if path fails.")
        end
    end)
    check:SetScript("OnLeave", function()
        if GameTooltip then GameTooltip:Hide() end
    end)
end

local function OpenViewer(title, loadFn, entry)
    local f = _G[VIEWER_FRAME]
    if not f then Log("Frame not found: " .. VIEWER_FRAME); return end

    f.CurrentEntry = entry
    f.CurrentDisplayId = nil
    f.CurrentModelPath = nil
    f.CMVFallbackPath = nil
    -- Initialise variant state for this entry
    EnsureVariantUI(f)
    if entry and entry > 0 then
        local variants = GetVariantsForEntry(entry)
        f.CMVVariants    = variants
        f.CMVVariantIdx  = 1
    else
        f.CMVVariants   = {}
        f.CMVVariantIdx = 1
    end
    UpdateVariantUI(f)
    if f.PortraitFrame and f.PortraitFrame.Portrait then
        SetPortraitToTexture(f.PortraitFrame.Portrait, PORTRAIT_ICON)
        f.PortraitFrame:Show()
    end
    if f.DebugText     then f.DebugText:Hide()     end
    SetViewerTitle(title)

    local model = f.Model
    if not model then Log("No Model child on frame"); return end

    -- Kill any in-progress sequence
    f:SetScript("OnUpdate", nil)
    model:SetScript("OnUpdate", nil)

    model:ClearModel()
    -- Keep model frame visible so the new model can render when loaded (hiding can prevent draw on some clients)
    model:Show()
    f:Show()
    f:Raise()

    local tick    = 0
    local isAsync = false

    f:SetScript("OnUpdate", function()
        tick = tick + 1

        if tick == 1 then
            model:ClearModel()

        elseif tick == 2 then
            local loaded = loadFn(model)
            if not loaded then
                f:SetScript("OnUpdate", nil)
                ShowDebugText(
                    "Model failed to load.\n\n" ..
                    "/cmv path <path>\n" ..
                    "/cmv unit  (target first)"
                )
                return
            end
            isAsync = (model:GetScript("OnUpdate") ~= nil)

        elseif tick >= 5 then
            f:SetScript("OnUpdate", nil)
            f:Raise()
            if not isAsync then
                -- Synchronous load: apply camera now that model is fully resident; respect debug panel camera
                f.CMVScale = DEFAULT_SCALE
                local df = _G[DEBUG_FRAME]
                local camOverride = (df and df.CameraValue ~= nil) and df.CameraValue or nil
                InitCamera(model, DEFAULT_SCALE, camOverride)
                model:Show()
                -- When we used SetCreature: re-apply one frame after Show; then check if model actually drew (some clients don't draw SetCreature).
                local displayId = f.CurrentDisplayId
                local currentEntry = f.CurrentEntry  -- must use entry, not displayId, for SetCreature
                local fallbackPath = f.CMVFallbackPath
                if displayId and currentEntry and model.SetCreature then
                    local checkTicks = 0
                    model:SetScript("OnUpdate", function(self)
                        checkTicks = checkTicks + 1
                        if checkTicks == 1 then
                            -- Re-apply with the creature entry so textures load correctly
                            pcall(self.SetCreature, self, currentEntry)
                            InitCamera(self, f.CMVScale or DEFAULT_SCALE, camOverride)
                            self:Show()
                            return
                        end
                        if checkTicks >= 5 then
                            self:SetScript("OnUpdate", nil)
                            -- If client didn't load a model (GetModel empty) or loaded .mdx (often doesn't render in viewer), fall back to path so something is visible
                            local currentPath = self:GetModel()
                            local needFallback = (not currentPath or currentPath == "")
                            if not needFallback and type(currentPath) == "string" and currentPath:lower():match("%.mdx$") then
                                needFallback = true  -- .mdx from SetCreature often doesn't appear; use SetModel(.m2)
                            end
                            if needFallback and fallbackPath and type(fallbackPath) == "string" then
                                Log("CMV: SetCreature did not draw (empty or .mdx), falling back to SetModel(path)")
                                f.CurrentDisplayId = nil
                                f.CMVFallbackPath = nil
                                self:ClearModel()
                                if LoadByPath(self, fallbackPath) then
                                    InitCamera(self, f.CMVScale or DEFAULT_SCALE, camOverride)
                                    self:Show()
                                end
                            end
                            self:SetScript("OnUpdate", OnModelUpdate)
                            if df and df:IsVisible() and type(RefreshDebugPanel) == "function" then
                                RefreshDebugPanel()
                            end
                            return
                        end
                    end)
                else
                    if model:GetScript("OnUpdate") ~= OnModelUpdate then
                        model:SetScript("OnUpdate", OnModelUpdate)
                    end
                end
            else
                -- Async (SetUnit): ensure model is visible and restore drag handler
                model:Show()
                model:SetScript("OnUpdate", OnModelUpdate)
            end
            -- Apply debug panel's current camera so new model matches displayed value (no desync)
            local df = _G[DEBUG_FRAME]
            if df and df.CameraValue ~= nil then
                pcall(model.SetCamera, model, df.CameraValue)
            end
            if df and df:IsVisible() and type(RefreshDebugPanel) == "function" then
                RefreshDebugPanel()
            end
        end
    end)
end

-- Reload the current model with the current texture preference (e.g. after checkbox toggle).
-- Must be local and defined after OpenViewer so it can call it. Expose for checkbox OnClick (WoW may not capture local in closure).
local function ReloadCurrentModel()
    local f = _G[VIEWER_FRAME]
    if not f then return end
    if f.CurrentEntry and f.CurrentEntry > 0 then
        OpenViewer("Entry " .. f.CurrentEntry, MakeEntryLoader(f.CurrentEntry, f.CurrentDisplayId), f.CurrentEntry)
    elseif f.CurrentModelPath and f.CurrentModelPath ~= "" then
        OpenViewer(f.CurrentModelPath, MakePathLoader(f.CurrentModelPath), nil)
    end
end
_G.MagicCoreCMV_ReloadCurrentModel = ReloadCurrentModel

-- ── Mouse controls ────────────────────────────────────────────────────────────
--
-- Scroll: zoom. Left-drag: Y rotation (SetFacing). Shift+Left-drag or Right-drag: pan (move model up/down/left/right). Middle-drag: Z rotation (roll).

local PAN_SENSITIVITY = 0.008
local ROLL_SENSITIVITY = 0.01

local drag = { rotating = false, rolling = false, panning = false, lastX = 0, lastY = 0 }

-- Apply Z rotation (roll); WotLK may use SetRotation or SetRoll (radians).
local function ApplyModelRoll(model, rollRad)
    if not model then return end
    if model.SetRoll then pcall(model.SetRoll, model, rollRad) end
    if model.SetRotation then pcall(model.SetRotation, model, rollRad) end
end

local function OnMouseWheel(self, delta)
    local model = self.Model
    if not model then return end
    local current = self.CMVScale or DEFAULT_SCALE
    local new     = math.max(0.01, math.min(10.0, current + delta * 0.05))
    self.CMVScale = new
    model:SetModelScale(new)
end

local function OnModelMouseDown(self, btn)
    local x, y = GetCursorPosition()
    if btn == "LeftButton" then
        if IsShiftKeyDown() then
            drag.panning  = true
            drag.lastX    = x
            drag.lastY    = y
        else
            drag.rotating = true
            drag.lastX    = x
        end
    elseif btn == "RightButton" then
        drag.panning  = true
        drag.lastX    = x
        drag.lastY    = y
    elseif btn == "MiddleButton" then
        drag.rolling  = true
        drag.lastX    = x
        local parent = self:GetParent()
        if parent and parent.ModelRoll == nil then parent.ModelRoll = 0 end
    end
end

local function OnModelMouseUp(self, btn)
    if not btn or btn == "LeftButton" then
        drag.rotating = false
        drag.panning  = false
    end
    if not btn or btn == "RightButton" then drag.panning = false end
    if not btn or btn == "MiddleButton" then drag.rolling = false end
end

function OnModelUpdate(self)
    local x, y = GetCursorPosition()
    local parent = self:GetParent()
    -- Left-drag rotation: use SetRotation(angle) like Character Info / Dressing Room (UIParent.lua Model_RotateLeft/Right)
    if drag.rotating then
        local dx = x - drag.lastX
        drag.lastX = x
        local rot = self.rotation
        if rot == nil then rot = 0.61 end
        rot = rot - dx * 0.03  -- 0.03 = same increment as Model_RotateLeft
        if rot < 0 then rot = rot + (2 * math.pi) end
        if rot >= 2 * math.pi then rot = rot - (2 * math.pi) end
        self.rotation = rot
        pcall(self.SetRotation, self, rot)
    end
    if drag.rolling then
        local dx = x - drag.lastX
        drag.lastX = x
        if parent then
            parent.ModelRoll = (parent.ModelRoll or 0) + dx * ROLL_SENSITIVITY
            ApplyModelRoll(self, parent.ModelRoll)
        end
    end
    if drag.panning then
        local dx = x - drag.lastX
        local dy = y - drag.lastY
        drag.lastX = x
        drag.lastY = y
        local px, py, pz = 0, 0, 0
        if self.GetPosition then
            local a, b, c = self:GetPosition()
            if a then px, py, pz = a, b or 0, c or 0 end
        end
        self:SetPosition(px - dx * PAN_SENSITIVITY, py, pz + dy * PAN_SENSITIVITY)
    end
    -- Re-apply rotation and scale every frame (newer M2s: animation can overwrite; SetRotation rotates whole view)
    local rot = self.rotation
    if rot == nil then self.rotation = 0.61; rot = 0.61 end
    pcall(self.SetRotation, self, rot)
    if parent then
        local scale = parent.CMVScale or DEFAULT_SCALE
        self:SetModelScale(scale)
        -- If user chose an animation: don't touch it every frame (that freezes playback). Only re-apply sequence
        -- periodically so the client doesn't revert to Stand for as long as possible.
        local seq = parent.CMVSequence
        if type(seq) == "number" then
            local now = GetTime()
            local last = self._lastSequenceApply or 0
            if now - last > 10 then
                self._lastSequenceApply = now
                pcall(self.SetSequence, self, seq)
            end
        else
            FreezeModelPose(self)
        end
    else
        FreezeModelPose(self)
    end
end

local function OnHide(self)
    self:SetScript("OnUpdate", nil)
    if self.Model then
        self.Model:SetScript("OnUpdate", nil)
        self.Model:ClearModel()
    end
    self.CMVScale = DEFAULT_SCALE  -- reset for next open
    local df = _G[DEBUG_FRAME]
    if df then df:Hide() end
end

-- ── Debug panel: visibility toggle + atlas icons ──────────────────────────────

local function SetButtonAtlas(btn, normal, highlight, pushed)
    if not btn then return end
    local ok
    if SetAtlas then
        local n, h, p = btn:GetNormalTexture(), btn:GetHighlightTexture(), btn:GetPushedTexture()
        if n then ok = pcall(SetAtlas, n, normal, true) end
        if h and (highlight or normal) then pcall(SetAtlas, h, highlight or normal, true) end
        if p and (pushed or normal) then pcall(SetAtlas, p, pushed or normal, true) end
    end
    if not ok and btn.SetNormalTexture then
        local n = btn:GetNormalTexture()
        if n and n.SetTexture then n:SetTexture("Interface\\Buttons\\" .. normal) end
    end
end

local function UpdateDebugToggleButton(showDebug)
    local f = _G[VIEWER_FRAME]
    if not f or not f.DebugToggleButton then return end
    if showDebug then
        SetButtonAtlas(f.DebugToggleButton, ATLAS_VIS_OFF, ATLAS_VIS_OFF_H, ATLAS_VIS_OFF_P)
    else
        SetButtonAtlas(f.DebugToggleButton, ATLAS_VIS_ON, ATLAS_VIS_ON_H, ATLAS_VIS_ON_P)
    end
end

local function CreateMinimalDebugFrame()
    if _G[DEBUG_FRAME] then return end
    local vf = _G[VIEWER_FRAME]
    if not vf then return end
    local df = CreateFrame("Frame", DEBUG_FRAME, UIParent)
    df:SetSize(280, 340)
    df:SetPoint("LEFT", vf, "RIGHT", 10, 0)
    df:SetMovable(true)
    df:EnableMouse(true)
    df:RegisterForDrag("LeftButton")
    df:SetScript("OnDragStart", function(self) self:StartMoving() end)
    df:SetScript("OnDragStop", function(self) self:StopMovingOrSizing() end)
    df:Hide()
    local bg = df:CreateTexture(nil, "BACKGROUND")
    bg:SetAllPoints(df)
    SetSolidColor(bg, 0.15, 0.15, 0.2, 0.95)
    local border = df:CreateTexture(nil, "BORDER")
    border:SetAllPoints(df)
    SetSolidColor(border, 0.4, 0.4, 0.5, 1)
    df.DebugInfo = df:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
    df.DebugInfo:SetPoint("TOP", df, "TOP", 0, -30)
    df.DebugInfo:SetWidth(260)
    df.DebugInfo:SetJustifyH("LEFT")
    df.DebugInfo:SetText("Model Debug — open a creature to see info.")
    local close = CreateFrame("Button", nil, df)
    close:SetSize(24, 24)
    close:SetPoint("TOPRIGHT", df, "TOPRIGHT", -4, -4)
    close:SetScript("OnClick", function()
        df:Hide()
        UpdateDebugToggleButton(false)
    end)
    local ctex = close:CreateTexture(nil, "BACKGROUND")
    ctex:SetAllPoints(close)
    SetSolidColor(ctex, 0.6, 0.2, 0.2, 1)
    close:SetNormalFontObject("GameFontNormalSmall")
    close:SetText("X")
    df:SetScript("OnHide", function() UpdateDebugToggleButton(false) end)
end

local function GetDebugInfoFontString(df)
    if not df then return nil end
    if df.DebugInfo then return df.DebugInfo end
    local name = df:GetName()
    if name then
        df.DebugInfo = _G[name .. "DebugInfo"]
    end
    if not df.DebugInfo then
        df.DebugInfo = df:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")
        df.DebugInfo:SetPoint("TOP", df, "TOP", 0, -45)
        df.DebugInfo:SetWidth(240)
        df.DebugInfo:SetJustifyH("LEFT")
    end
    return df.DebugInfo
end

local ENTRY_TITLE_ATLAS = "UI-Character-Info-Title"
local CAMERA_MIN, CAMERA_MAX = 0, 1

-- Common M2 sequence indices -> display name (standard WoW creature/character animations). Indices without a name show as "Sequence N".
local SEQUENCE_NAMES = {
    [0] = "Stand", [1] = "Death", [2] = "Death (alt)", [4] = "Walk", [5] = "Run", [6] = "Dead",
    [7] = "Jump", [8] = "Fall", [9] = "Swim Idle", [10] = "Swim", [11] = "Swim Back",
    [12] = "Attack Unarmed", [13] = "Attack 1H", [14] = "Attack 2H", [15] = "Attack 2HL",
    [16] = "Parry Unarmed", [17] = "Parry 1H", [18] = "Parry 2H", [19] = "Parry 2HL", [20] = "Shield Block",
    [21] = "Ready Unarmed", [22] = "Ready 1H", [23] = "Ready 2H", [24] = "Ready 2HL", [25] = "Ready Bow",
    [26] = "Attack 1H (2)", [27] = "Attack 2H (2)", [28] = "Attack 2HL (2)", [29] = "Attack Unarmed (2)",
    [30] = "Dodge", [31] = "Spell Precast", [32] = "Spell Cast", [33] = "Spell Cast (2)", [34] = "Spell (channel)",
    [35] = "Attack 2H (3)", [36] = "Attack 2H (4)", [37] = "Jump (2)", [38] = "Jump (3)", [39] = "Jump (4)",
    [40] = "Fly Stand", [41] = "Fly Run", [42] = "Fly", [43] = "Fly (2)", [44] = "Fly (3)", [45] = "Fly (4)",
    [46] = "Fly (5)", [47] = "Fly (6)", [48] = "Fly (7)", [49] = "Fly (8)", [50] = "Fly (9)",
    [51] = "Ready Spell", [52] = "Spell (2)", [53] = "Spell (3)", [54] = "Spell (4)", [55] = "Spell (5)",
    [56] = "Spell (6)", [57] = "Spell (7)", [58] = "Spell (8)", [59] = "Spell (9)",
    [60] = "Talk", [61] = "Talk (2)", [62] = "Talk (3)", [63] = "Talk (4)", [64] = "Talk (5)",
    [65] = "Talk (6)", [66] = "Bow", [67] = "Wave", [68] = "Cheer", [69] = "Dance", [70] = "Laugh",
    [71] = "Cry", [72] = "Drowned", [73] = "Mount", [74] = "Mount (2)", [75] = "Mount (3)", [76] = "Mount (4)",
    [77] = "Mount (5)", [78] = "Mount (6)", [79] = "Mount (7)", [80] = "Mount (8)", [81] = "Mount (9)",
    [82] = "Mount (10)", [83] = "Mount (11)", [84] = "Mount (12)", [85] = "Mount (13)", [86] = "Mount (14)",
    [87] = "Mount (15)", [88] = "Mount (16)", [89] = "Mount (17)", [90] = "Mount (18)", [91] = "Mount (19)",
    [92] = "Mount (20)", [93] = "Mount (21)", [94] = "Attack Unarmed (3)", [95] = "Attack 1H (3)",
    [96] = "Attack 2H (5)", [97] = "Attack 2HL (3)", [98] = "Emote (sit)", [99] = "Emote (sit 2)",
    [100] = "Emote (sleep)", [101] = "Emote (sit 3)", [102] = "Emote (kneel)", [103] = "Emote (kneel 2)",
    [104] = "Emote (2)", [105] = "Emote (3)", [106] = "Emote (4)", [107] = "Emote (5)", [108] = "Emote (6)",
    [109] = "Emote (7)", [110] = "Emote (8)", [111] = "Emote (9)", [112] = "Emote (10)", [113] = "Loot",
    [114] = "Stun", [115] = "Close", [116] = "Open", [117] = "Work", [118] = "Eat", [119] = "Repair",
    [120] = "Train", [121] = "Spell (10)", [122] = "Spell (11)", [123] = "Spell (12)", [124] = "Spell (13)",
    [125] = "Spell (14)", [126] = "Spell (15)", [127] = "Spell (16)",
    [158] = "Hold", [159] = "Decay",
}
local SEQUENCE_MAX = 128  -- 0..127 standard; 158/159 used by some models
-- Freeze + these sequences in the animation dropdown (custom popup supports any count)
local DROPDOWN_SEQUENCES = { 0, 4, 5, 1, 7, 32, 69, 158, 159 }  -- Stand, Walk, Run, Death, Jump, Spell Cast, Dance, Hold, Decay

local ARROW_ATLAS     = "128-RedButton-ArrowDown"
local ARROW_ATLAS_H   = "128-RedButton-ArrowDown-Highlight"
local ARROW_ATLAS_P   = "128-RedButton-ArrowDown-Pressed"
-- Fallback when atlas texture is missing (standard WotLK spellbook arrows)
local ARROW_TEX_LEFT  = "Interface\\Buttons\\UI-SpellbookIcon-PrevPage-Down"
local ARROW_TEX_RIGHT = "Interface\\Buttons\\UI-SpellbookIcon-NextPage-Down"

local function EnsurePathScrollFrame(df)
    if not df then return end
    if df.PathScrollFrame then return end
    local name = df:GetName()
    local existingPathText = name and _G[name .. "PathText"]
    local scrollFrame = CreateFrame("ScrollFrame", nil, df)
    scrollFrame:SetSize(256, 100)
    local scrollChild = CreateFrame("Frame", nil, scrollFrame)
    scrollChild:SetSize(256, 600)
    scrollFrame:SetScrollChild(scrollChild)
    scrollFrame:EnableMouseWheel(true)
    scrollFrame:SetScript("OnMouseWheel", function(_, delta)
        local step = 20
        local cur = scrollFrame:GetVerticalScroll()
        local range = 0
        if scrollFrame.GetVerticalScrollRange then
            range = scrollFrame:GetVerticalScrollRange()
        end
        if not range or range <= 0 then
            range = math.max(0, scrollChild:GetHeight() - scrollFrame:GetHeight())
        end
        local newValue = math.max(0, math.min(range, cur - (delta * step)))
        scrollFrame:SetVerticalScroll(newValue)
    end)
    local pathFontString
    if existingPathText then
        existingPathText:ClearAllPoints()
        existingPathText:SetParent(scrollChild)
        existingPathText:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, 0)
        existingPathText:SetPoint("RIGHT", scrollChild, "RIGHT", 0, 0)
        existingPathText:SetHeight(600)
        existingPathText:SetWordWrap(true)
        existingPathText:SetJustifyH("LEFT")
        pathFontString = existingPathText
    else
        pathFontString = scrollChild:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
        pathFontString:SetPoint("TOPLEFT", scrollChild, "TOPLEFT", 0, 0)
        pathFontString:SetPoint("RIGHT", scrollChild, "RIGHT", 0, 0)
        pathFontString:SetHeight(600)
        pathFontString:SetWordWrap(true)
        pathFontString:SetJustifyH("LEFT")
    end
    df.PathScrollFrame = scrollFrame
    df.PathText = pathFontString
end

local function GetPathTextFontString(df)
    if not df then return nil end
    EnsurePathScrollFrame(df)
    return df.PathText
end


local function GetSequenceLabel(idx)
    if type(idx) ~= "number" then return "Freeze" end
    return SEQUENCE_NAMES[idx] and (idx .. " " .. SEQUENCE_NAMES[idx]) or ("Sequence " .. idx)
end

local function EnsureAnimationRow(df)
    if not df then return end
    local row = df.AnimationRow
    if not row then
        row = CreateFrame("Frame", nil, df)
        row:SetSize(240, 26)
        row:SetPoint("BOTTOM", df, "BOTTOM", 0, 38)
        df.AnimationRow = row
    end
    if not df.AnimationLabel then
        local label = df:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
        label:SetPoint("LEFT", row, "LEFT", 0, 0)
        label:SetText("Animation:")
        df.AnimationLabel = label
    end
    if not df.AnimationButton then
        local btn = CreateFrame("Button", nil, df)
        btn:SetSize(160, 22)
        btn:SetPoint("LEFT", row, "LEFT", 70, 0)
        btn:SetFrameLevel(row:GetFrameLevel() + 2)
        local bg = btn:CreateTexture(nil, "BACKGROUND")
        bg:SetAllPoints(btn)
        SetSolidColor(bg, 0.15, 0.15, 0.2, 0.9)
        local text = btn:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
        text:SetPoint("LEFT", btn, "LEFT", 6, 0)
        text:SetPoint("RIGHT", btn, "RIGHT", -6, 0)
        text:SetJustifyH("LEFT")
        btn:SetFontString(text)
        btn.Text = text

        -- Custom popup menu (avoids UIDropDownMenu which may not show in addon context)
        local menu = CreateFrame("Frame", nil, df)
        menu:SetFrameStrata("FULLSCREEN_DIALOG")
        menu:SetFrameLevel(df:GetFrameLevel() + 50)
        menu:SetSize(170, (1 + #DROPDOWN_SEQUENCES) * 20 + 8)
        menu:Hide()
        local menuBg = menu:CreateTexture(nil, "BACKGROUND")
        menuBg:SetAllPoints(menu)
        SetSolidColor(menuBg, 0.12, 0.12, 0.18, 0.98)
        local menuBorder = menu:CreateTexture(nil, "BORDER")
        menuBorder:SetAllPoints(menu)
        SetSolidColor(menuBorder, 0.4, 0.4, 0.5, 1)
        df.AnimationMenu = menu

        local function hideMenu()
            if menu and menu:IsShown() then menu:Hide() end
        end

        local function setSequence(val, label)
            local vf = _G[VIEWER_FRAME]
            if not vf then return end
            vf.CMVSequence = val
            if vf.Model then
                if val == nil then
                    FreezeModelPose(vf.Model)
                else
                    vf.Model._lastSequenceApply = GetTime()
                    pcall(vf.Model.SetSequence, vf.Model, val)
                    pcall(vf.Model.SetSequenceTime, vf.Model, val, 0)
                end
            end
            local t = btn.Text or (btn.GetFontString and btn:GetFontString())
            if t and t.SetText then t:SetText(label or "Freeze") end
            if df and df:IsVisible() and type(RefreshDebugPanel) == "function" then RefreshDebugPanel() end
            hideMenu()
        end

        local items = { { label = "Freeze (pose)", value = nil } }
        for _, idx in ipairs(DROPDOWN_SEQUENCES) do
            items[#items + 1] = { label = GetSequenceLabel(idx), value = idx }
        end

        for i, item in ipairs(items) do
            local rowBtn = CreateFrame("Button", nil, menu)
            rowBtn:SetSize(162, 18)
            rowBtn:SetPoint("TOPLEFT", menu, "TOPLEFT", 4, -4 - (i - 1) * 20)
            local rowBg = rowBtn:CreateTexture(nil, "BACKGROUND")
            rowBg:SetAllPoints(rowBtn)
            SetSolidColor(rowBg, 0.2, 0.2, 0.28, 0.9)
            rowBtn:SetHighlightTexture(rowBg)
            local rowText = rowBtn:CreateFontString(nil, "OVERLAY", "GameFontHighlightSmall")
            rowText:SetPoint("LEFT", rowBtn, "LEFT", 6, 0)
            rowText:SetJustifyH("LEFT")
            rowText:SetText(item.label)
            rowBtn:SetFontString(rowText)
            rowBtn:SetScript("OnClick", function()
                setSequence(item.value, item.value == nil and "Freeze" or item.label)
            end)
        end

        menu:SetScript("OnHide", function()
            if menu.clickCatcher and menu.clickCatcher:IsShown() then menu.clickCatcher:Hide() end
        end)

        btn:SetScript("OnClick", function(self)
            local vf = _G[VIEWER_FRAME]
            if not vf then return end
            if menu:IsShown() then
                menu:Hide()
                return
            end
            menu:ClearAllPoints()
            menu:SetPoint("TOPLEFT", self, "BOTTOMLEFT", 0, -2)
            menu:Show()
            -- Click catcher to close menu when clicking outside (create once)
            if not menu.clickCatcher then
                local catcher = CreateFrame("Button", nil, UIParent)
                catcher:SetFrameStrata("FULLSCREEN_DIALOG")
                catcher:SetFrameLevel(menu:GetFrameLevel() - 1)
                catcher:SetAllPoints(UIParent)
                catcher:SetScript("OnClick", function()
                    hideMenu()
                    catcher:Hide()
                end)
                menu.clickCatcher = catcher
            end
            menu.clickCatcher:SetFrameLevel(menu:GetFrameLevel() - 1)
            menu.clickCatcher:Show()
        end)

        df.AnimationButton = btn
    end
    -- Update button text to current sequence
    local vf = _G[VIEWER_FRAME]
    local seq = vf and vf.CMVSequence
    local txt = df.AnimationButton and df.AnimationButton:GetFontString()
    if txt then txt:SetText(type(seq) == "number" and GetSequenceLabel(seq) or "Freeze") end
end

RefreshDebugPanel = function()
    local df = _G[DEBUG_FRAME]
    local vf = _G[VIEWER_FRAME]
    if not df or not df:IsVisible() or not vf or not vf.Model then return end
    -- Keep "Prefer textures" checkbox in sync with global (e.g. after off/on/off/on toggles)
    SetupPreferTexturesCheck(vf)
    local info = GetDebugInfoFontString(df)
    local pathText = GetPathTextFontString(df)
    local m = vf.Model
    -- GetModel() is often empty or may return a non-string userdata; normalize to a string.
    local path = nil
    if m.GetModel then
        local ok, result = pcall(m.GetModel, m)
        if ok and type(result) == "string" then
            path = result
        else
            path = ""
        end
    else
        path = ""
    end
    if path == "" and vf.CurrentModelPath and vf.CurrentModelPath ~= "" then
        path = vf.CurrentModelPath:gsub("/", "\\")  -- display with backslashes like client paths
    end
    if path == "" then path = "(none)" end
    local entry = vf.CurrentEntry or "-"
    local displayId = vf.CurrentDisplayId or (type(entry) == "number" and entry > 0 and GetDisplayIdFromEntry(entry)) or nil
    local scale = vf.CMVScale or m:GetModelScale() or DEFAULT_SCALE
    local facing = m:GetFacing()
    if facing == nil then facing = 0 end
    local cam = (df.CameraValue ~= nil) and df.CameraValue or (m.GetCamera and m:GetCamera()) or 0
    df.CameraValue = cam

    -- Path status: OK or NO PATH
    local hasPath = path and path ~= "" and path ~= "(none)"
    local pathStatus = hasPath and "OK" or "NO PATH"
    if pathText then
        pathText:SetWordWrap(true)
        pathText:SetText(hasPath and path or ("NO PATH — run: tswow datascripts build"))
        if hasPath then
            pathText:SetTextColor(0.85, 0.85, 0.7)
        else
            pathText:SetTextColor(1, 0.4, 0.3)
        end
    end

    -- BLP / texture data from CreatureDisplayTexturesMap (expected texture names for this displayId)
    local textureListStr = ""
    if type(CreatureDisplayTexturesMap) == "table" and displayId and (tonumber(displayId) or 0) > 0 then
        local did = tonumber(displayId)
        local texList = (CreatureDisplayTexturesMap[did] or (did and CreatureDisplayTexturesMap[tostring(did)]))
        if type(texList) == "table" and #texList > 0 then
            textureListStr = table.concat(texList, ", ")
        else
            textureListStr = "No BLP data in map — model may show gray. Run: tswow datascripts build"
        end
    else
        textureListStr = (displayId and displayId > 0) and "No texture map for displayId " .. tostring(displayId) or "No displayId (loaded by path only)"
    end

    -- Load method (helps explain gray model: SetModel(path) doesn't apply DBC textures)
    local loadMethod = (vf.CurrentDisplayId and vf.CurrentDisplayId > 0) and ("SetCreature(" .. tostring(vf.CurrentDisplayId) .. ")") or "SetModel(path)"

    -- Entry ID in title bar
    local entryTitle = df.EntryTitleFrame or (df.GetName and _G[df:GetName() .. "EntryTitleFrame"])
    if entryTitle then
        local entryText = entryTitle.EntryText or (entryTitle.GetName and _G[entryTitle:GetName() .. "EntryText"])
        if entryText then entryText:SetText(tostring(entry)) end
    end

    -- Debug summary: Display ID, Path status, model path, Scale, Facing, Load method, BLP list
    local pathForInfo
    if type(path) == "string" and path ~= "" and path ~= "(none)" then
        pathForInfo = path
    elseif vf.CurrentModelPath and type(vf.CurrentModelPath) == "string" and vf.CurrentModelPath ~= "" then
        pathForInfo = vf.CurrentModelPath:gsub("/", "\\")
    else
        pathForInfo = "(no path)"
    end
    if info then
        info:SetWidth(256)
        info:SetHeight(200)
        info:SetWordWrap(true)
        info:SetText(
            "Display ID: " .. (displayId and tostring(displayId) or "-") .. "  Path: " .. pathStatus .. "\n" ..
            "Model: " .. pathForInfo .. "\n" ..
            string.format("Scale: %.4f  Facing: %.4f  Load: %s\n", scale, facing, loadMethod) ..
            "BLP (expected): " .. textureListStr
        )
    end
    -- SetCamera value label (center between arrow buttons)
    local valText = df.CameraValueText
    if valText and valText.SetText then
        valText:SetText("SetCamera " .. tostring(cam))
    end
    if df.ScaleEdit then df.ScaleEdit:SetText(tostring(scale)) end
    if df.FacingEdit then df.FacingEdit:SetText(string.format("%.4f", facing)) end
    local px, py, pz = 0, 0, 0
    if m.GetPosition then
        local a, b, c = m:GetPosition()
        if a then px, py, pz = a, b or 0, c or 0 end
    end
    if df.PosXEdit then df.PosXEdit:SetText(tostring(px)) end
    if df.PosYEdit then df.PosYEdit:SetText(tostring(py)) end
    if df.PosZEdit then df.PosZEdit:SetText(tostring(pz)) end
    EnsureAnimationRow(df)
    -- Model path (.m2) in scrollable area above the Animation row
    local pathScroll = df.PathScrollFrame
    if pathScroll and df.AnimationRow then
        pathScroll:ClearAllPoints()
        pathScroll:SetPoint("BOTTOM", df.AnimationRow, "TOP", 0, 6)
        pathScroll:SetPoint("LEFT", df, "LEFT", 12, 0)
        pathScroll:SetPoint("RIGHT", df, "RIGHT", -12, 0)
        local scrollChild = pathScroll:GetScrollChild()
        if scrollChild and pathScroll:GetWidth() > 0 then
            scrollChild:SetWidth(pathScroll:GetWidth())
        end
    end
end

local function ApplyDebugValues()
    local df = _G[DEBUG_FRAME]
    local vf = _G[VIEWER_FRAME]
    if not df or not vf or not vf.Model then return end
    local m = vf.Model
    local function num(val, default)
        if val == nil or val == "" then return default end
        return tonumber(val) or default
    end
    local cam = (df.CameraValue ~= nil) and df.CameraValue or 0
    cam = math.max(CAMERA_MIN, math.min(CAMERA_MAX, cam))
    df.CameraValue = cam
    local scale = num(df.ScaleEdit and df.ScaleEdit:GetText(), DEFAULT_SCALE)
    local px = num(df.PosXEdit and df.PosXEdit:GetText(), 0)
    local py = num(df.PosYEdit and df.PosYEdit:GetText(), 0)
    local pz = num(df.PosZEdit and df.PosZEdit:GetText(), 0)
    local facing = num(df.FacingEdit and df.FacingEdit:GetText(), 0)
    pcall(m.SetCamera, m, cam)
    pcall(m.SetPosition, m, px, py, pz)
    m:SetModelScale(scale)
    m:SetFacing(facing)
    vf.CMVScale = scale
    RefreshDebugPanel()
end

-- Set arrow texture. Tries atlas first (Interface/Shop/CatalogShop128RedButton); fallback to standard UI arrows.
-- rotationRad: -pi/2 = left arrow, pi/2 = right arrow (left = PrevPage, right = NextPage).
local function SetArrowTexture(tex, atlas, _, _, rotationRad)
    if not tex then return end
    local ok
    if SetAtlas and atlas and C_Texture and C_Texture.GetAtlasInfo and C_Texture.GetAtlasInfo(atlas) then
        ok = pcall(SetAtlas, tex, atlas, false)
    end
    if not ok then
        local isLeft = rotationRad and math.abs(rotationRad + math.pi / 2) < 0.001
        local path = isLeft and ARROW_TEX_LEFT or ARROW_TEX_RIGHT
        tex:SetTexture(path)
        tex:SetTexCoord(0, 1, 0, 1)
    end
    tex:Show()
end

local function EnsureCameraRowAndDropdown(df)
    if not df then return end
    local row = df.CameraRow
    if not row then
        row = CreateFrame("Frame", nil, df)
        row:SetSize(240, 26)
        row:SetPoint("BOTTOM", df, "BOTTOM", 0, 10)
        df.CameraRow = row
    end

    -- Center label: "SetCamera 0" or "SetCamera 1"
    if not df.CameraValueText then
        local valText = df:CreateFontString(nil, "OVERLAY", "GameFontHighlight")
        valText:SetPoint("CENTER", row, "CENTER", 0, 0)
        valText:SetText("SetCamera " .. tostring(df.CameraValue or 0))
        df.CameraValueText = valText
    end

    -- Left button: decrease (arrow rotated 90° right = points left)
    if not df.CameraDecButton then
        local left = CreateFrame("Button", nil, df)
        left:SetSize(28, 28)
        left:SetPoint("RIGHT", row, "CENTER", -60, 0)
        left:SetFrameLevel(row:GetFrameLevel() + 2)
        local n = left:CreateTexture(nil, "ARTWORK")
        n:SetAllPoints(left)
        SetArrowTexture(n, ARROW_ATLAS, nil, nil, -math.pi / 2)
        if left.SetNormalTexture then left:SetNormalTexture(n) end
        local h = left:CreateTexture(nil, "HIGHLIGHT")
        h:SetAllPoints(left)
        SetArrowTexture(h, ARROW_ATLAS_H, nil, nil, -math.pi / 2)
        if left.SetHighlightTexture then left:SetHighlightTexture(h) end
        local p = left:CreateTexture(nil, "ARTWORK")
        p:SetAllPoints(left)
        SetArrowTexture(p, ARROW_ATLAS_P, nil, nil, -math.pi / 2)
        if left.SetPushedTexture then left:SetPushedTexture(p) end
        left:SetScript("OnClick", function()
            local vf = _G[VIEWER_FRAME]
            local cur = (df.CameraValue ~= nil) and df.CameraValue or 0
            local nextVal = math.max(CAMERA_MIN, cur - 1)
            df.CameraValue = nextVal
            if vf and vf.Model then pcall(vf.Model.SetCamera, vf.Model, nextVal) end
            if df.CameraValueText then df.CameraValueText:SetText("SetCamera " .. tostring(nextVal)) end
        end)
        left:Show()
        df.CameraDecButton = left
    end

    -- Right button: increase (arrow rotated 90° left = points right)
    if not df.CameraIncButton then
        local right = CreateFrame("Button", nil, df)
        right:SetSize(28, 28)
        right:SetPoint("LEFT", row, "CENTER", 60, 0)
        right:SetFrameLevel(row:GetFrameLevel() + 2)
        local n = right:CreateTexture(nil, "ARTWORK")
        n:SetAllPoints(right)
        SetArrowTexture(n, ARROW_ATLAS, nil, nil, math.pi / 2)
        if right.SetNormalTexture then right:SetNormalTexture(n) end
        local h = right:CreateTexture(nil, "HIGHLIGHT")
        h:SetAllPoints(right)
        SetArrowTexture(h, ARROW_ATLAS_H, nil, nil, math.pi / 2)
        if right.SetHighlightTexture then right:SetHighlightTexture(h) end
        local p = right:CreateTexture(nil, "ARTWORK")
        p:SetAllPoints(right)
        SetArrowTexture(p, ARROW_ATLAS_P, nil, nil, math.pi / 2)
        if right.SetPushedTexture then right:SetPushedTexture(p) end
        right:SetScript("OnClick", function()
            local vf = _G[VIEWER_FRAME]
            local cur = (df.CameraValue ~= nil) and df.CameraValue or 0
            local nextVal = math.min(CAMERA_MAX, cur + 1)
            df.CameraValue = nextVal
            if vf and vf.Model then pcall(vf.Model.SetCamera, vf.Model, nextVal) end
            if df.CameraValueText then df.CameraValueText:SetText("SetCamera " .. tostring(nextVal)) end
        end)
        right:Show()
        df.CameraIncButton = right
    end
end

-- ── Attach scripts (deferred so frame exists after XML load) ────────────────────

local function AttachViewerScripts()
    local frame = _G[VIEWER_FRAME]
    if not frame then return false end
    -- Don't use SetClipsChildren(false): on some clients it can prevent PlayerModel from rendering
    frame:SetScript("OnHide",       OnHide)
    frame:SetScript("OnMouseWheel", OnMouseWheel)
    frame:EnableMouseWheel(true)
    if frame.Model then
        frame.Model:SetScript("OnMouseDown", OnModelMouseDown)
        frame.Model:SetScript("OnMouseUp",   OnModelMouseUp)
        frame.Model:SetScript("OnUpdate",    OnModelUpdate)
        frame.Model:EnableMouse(true)
    end
    if frame.SpawnButton then
        SetButtonAtlas(frame.SpawnButton, ATLAS_SPAWN, ATLAS_SPAWN_H, ATLAS_SPAWN_P)
        frame.SpawnButton:SetScript("OnClick", function(btn)
            local e = btn:GetParent().CurrentEntry
            if e and e > 0 then
                local eb = ChatFrame1EditBox
                if eb then eb:SetText(".npc add " .. e); ChatEdit_SendText(eb, 0) end
            else Log("No entry — open a creature link first") end
        end)
        frame.SpawnButton:SetScript("OnEnter", function(self)
            if GameTooltip then
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                GameTooltip:SetText("Spawns current selected Creature", 1, 1, 1)
                GameTooltip:Show()
            end
        end)
        frame.SpawnButton:SetScript("OnLeave", function()
            if GameTooltip then GameTooltip:Hide() end
        end)
        local st = frame.SpawnButton.Text or frame.SpawnButton
        if st and st.SetText then st:SetText("") end
    end
    if frame.DeleteButton then
        SetButtonAtlas(frame.DeleteButton, ATLAS_DELETE, ATLAS_DELETE_H, ATLAS_DELETE_P)
        frame.DeleteButton:SetScript("OnClick", function(btn)
            local e = btn:GetParent().CurrentEntry
            if e and e > 0 then
                local eb = ChatFrame1EditBox
                if eb then eb:SetText(".npc delete"); ChatEdit_SendText(eb, 0) end
            else Log("No entry — open a creature link first") end
        end)
        frame.DeleteButton:SetScript("OnEnter", function(self)
            if GameTooltip then
                GameTooltip:SetOwner(self, "ANCHOR_RIGHT")
                GameTooltip:SetText("Deletes selected Creature", 1, 1, 1)
                GameTooltip:Show()
            end
        end)
        frame.DeleteButton:SetScript("OnLeave", function()
            if GameTooltip then GameTooltip:Hide() end
        end)
        local dt = frame.DeleteButton.Text or frame.DeleteButton
        if dt and dt.SetText then dt:SetText("") end
    end
    if frame.DebugToggleButton then
        local dt = frame.DebugToggleButton.Text or frame.DebugToggleButton
        if dt and dt.SetText then dt:SetText("") end
        UpdateDebugToggleButton(false)
        frame.DebugToggleButton:SetScript("OnClick", function()
            local df = _G[DEBUG_FRAME]
            if not df then
                CreateMinimalDebugFrame()
                df = _G[DEBUG_FRAME]
            end
            if not df then return end
            if df:IsVisible() then
                df:Hide()
                UpdateDebugToggleButton(false)
            else
                df:ClearAllPoints()
                df:SetPoint("LEFT", frame, "RIGHT", 10, 0)
                EnsureCameraRowAndDropdown(df)
                EnsureAnimationRow(df)
                df:Show()
                df:Raise()
                UpdateDebugToggleButton(true)
                RefreshDebugPanel()
            end
        end)
    end
    local df = _G[DEBUG_FRAME]
    if df then
        if df.PortraitFrame and df.PortraitFrame.Portrait then
            SetPortraitToTexture(df.PortraitFrame.Portrait, DEBUG_PORTRAIT_ICON)
        end
        local entryTitle = df.EntryTitleFrame or (df.GetName and _G[df:GetName() .. "EntryTitleFrame"])
        if entryTitle and entryTitle.Bg and SetAtlas then
            pcall(SetAtlas, entryTitle.Bg, ENTRY_TITLE_ATLAS, true)
        end
        EnsureCameraRowAndDropdown(df)
        EnsureAnimationRow(df)
        df:SetScript("OnHide", function()
            UpdateDebugToggleButton(false)
        end)
        if df.ApplyButton then
            if df.ApplyButton.SetText then df.ApplyButton:SetText("Apply") end
            df.ApplyButton:SetScript("OnClick", ApplyDebugValues)
        end
    end
    return true
end

do
    local loader = CreateFrame("Frame")
    loader:SetScript("OnUpdate", function(self)
        if AttachViewerScripts() then
            self:SetScript("OnUpdate", nil)
        end
    end)
end

-- ── Hyperlink interception ────────────────────────────────────────────────────

local orig_SetItemRef = SetItemRef
function SetItemRef(link, text, button)
    if link and link:sub(1, 15) == "creature_entry:" then
        local rest      = link:sub(16)
        local entryStr, displayIdStr, encodedPath = rest:match("^(%d+):?(%d*):?(.*)")
        local entry     = tonumber(entryStr)
        local displayId = tonumber(displayIdStr)
        local modelPath = (encodedPath and encodedPath ~= "")
                          and encodedPath:gsub("%%20"," "):gsub("%%5[Cc]","\\")
                          or nil

        local title = text
            and text:gsub("|c%x%x%x%x%x%x%x%x",""):gsub("|r",""):match("^%s*(.-)%s*$")
            or ("Entry " .. tostring(entry))

        if entry then
            Log("CMV: opening creature_entry:" .. tostring(entry))
            local f = _G[VIEWER_FRAME]
            if not f then
                Log("CMV: viewer frame not found (addon may load after XML). Reload UI and try again.")
                return orig_SetItemRef(link, text, button)
            end
            if f then f.CMVScale = DEFAULT_SCALE end  -- reset scale for new creature

            OpenViewer(title, function(model)
                local rf = _G[VIEWER_FRAME]
                if modelPath then
                    if rf then rf.CurrentModelPath = NormalizePathForLookup(modelPath); rf.CurrentDisplayId = nil end
                    return LoadByPath(model, modelPath)
                end
                local resolvedPath, resolvedDisplayId = ResolvePathFromEntry(entry)
                if resolvedPath then
                    Log(string.format("entry %d → displayId %s → %s", entry, tostring(resolvedDisplayId), NormalizePathForLookup(resolvedPath) or resolvedPath))
                    if rf then rf.CurrentModelPath = NormalizePathForLookup(resolvedPath) end
                    if _G.MagicCoreCMVPreferTextures then
                        -- Prefer textures: SetCreature(entry) so the client resolves
                        -- entry → displayId → TextureVariation BLPs via patched Creature.dbc.
                        -- Using resolvedDisplayId here is WRONG — it's a CreatureDisplayInfo ID,
                        -- not a creature entry; the client finds a different or no creature.
                        if LoadByEntry(model, entry) then
                            if rf then rf.CurrentDisplayId = resolvedDisplayId; rf.CMVFallbackPath = NormalizePathForLookup(resolvedPath) end
                            return true
                        end
                    end
                    -- Default or fallback: SetModel(path) so model is always visible; textures may be wrong.
                    if LoadByPath(model, resolvedPath) then
                        if rf then rf.CurrentDisplayId = nil; rf.CMVFallbackPath = nil end
                        return true
                    end
                    if LoadByEntry(model, entry) then
                        if rf then rf.CurrentDisplayId = resolvedDisplayId; rf.CMVFallbackPath = NormalizePathForLookup(resolvedPath) end
                        return true
                    end
                    return false
                end
                -- Map had no entry (stale addon?) — if link includes displayId, resolve path from CreatureModelPathMap
                if displayId and displayId > 0 then
                    local p = GetPathFromDisplayId(displayId)
                    if p then
                        Log(string.format("entry %d (map nil) → using link displayId %d → %s", entry, displayId, p))
                        if rf then rf.CurrentModelPath = NormalizePathForLookup(p) end
                        if LoadByPath(model, p) then
                            if rf then rf.CurrentDisplayId = nil; rf.CMVFallbackPath = nil end
                            return true
                        end
                        if LoadByDisplayId(model, displayId) then
                            if rf then rf.CurrentDisplayId = displayId; rf.CMVFallbackPath = NormalizePathForLookup(p) end
                            return true
                        end
                    end
                end
                Log("CMV: no path for entry " .. tostring(entry) .. " (displayId from map: " .. tostring(GetDisplayIdFromEntry(entry)) .. ")")
                if rf then rf.CurrentModelPath = nil; rf.CurrentDisplayId = nil end
                ShowDebugText(
                    "No model path for entry " .. entry .. ".\n\n" ..
                    "1) Run: tswow datascripts build\n" ..
                    "2) Reload UI (/reload)\n" ..
                    "3) If addon is a copy, update it from\n   modules/magic-core/addon/\n\n" ..
                    "Or target the creature and use: /cmv unit\n" ..
                    "Or try: /cmv path Creature/.../model.mdx"
                )
                return false
            end, entry)
            return
        end
    end
    return orig_SetItemRef(link, text, button)
end

-- ── Slash commands ────────────────────────────────────────────────────────────

SLASH_CMV1 = "/cmv"
SlashCmdList["CMV"] = function(input)
    local msg = (input or ""):match("^%s*(.-)%s*$")

    if msg == "unit" then
        if not UnitExists("target") then Log("No target selected"); return end
        local name = UnitName("target") or "Target"
        local f = _G[VIEWER_FRAME]
        if f then f.CMVScale = DEFAULT_SCALE end
        OpenViewer(name, function(model)
            return LoadByUnitAsync(model, "target", function(m)
                m:Show()
                SetViewerTitle(name)
                m:SetScript("OnUpdate", OnModelUpdate)
            end)
        end)
        return
    end

    local path = msg:match("^path%s+(.+)$")
    if path then
        local f = _G[VIEWER_FRAME]
        if f then f.CMVScale = DEFAULT_SCALE end
        OpenViewer(path, MakePathLoader(path), nil)
        return
    end

    local entryStr, displayIdStr = msg:match("^(%d+)%s+(%d+)$")
    local entryOnly = msg:match("^(%d+)$")
    local entry     = tonumber(entryStr or entryOnly)
    local displayId = (displayIdStr and displayIdStr ~= "") and tonumber(displayIdStr) or nil
    if entry then
        local f = _G[VIEWER_FRAME]
        if f then f.CMVScale = DEFAULT_SCALE end
        OpenViewer("Entry " .. entry, MakeEntryLoader(entry, displayId), entry)
        return
    end

    Log("Commands:")
    Log("  /cmv unit             — show current target's model")
    Log("  /cmv <entry> [displayId] — show by entry (optional displayId if map is stale)")
    Log("  /cmv path <path>      — show by path (e.g. Creature/runesmith/runesmith.mdx)")
end

-- One-time setup of "Prefer textures" checkbox (frame created by XML, loaded before this Lua).
do
    local f = _G[VIEWER_FRAME]
    if f and f.PreferTexturesCheck then
        SetupPreferTexturesCheck(f)
    end
end
